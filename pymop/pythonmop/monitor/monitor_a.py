from pythonmop.monitor.formalismhandler.ere import Ere
from pythonmop.monitor.formalismhandler.fsm import Fsm
from pythonmop.monitor.formalismhandler.ltl import Ltl
from pythonmop.monitor.formalismhandler.cfg import Cfg
from pythonmop.monitor.formalismhandler.base import Base
from pythonmop.spec.data import SpecParameter
from pythonmop.logicplugin.plugin import EREData, FSMData, LTLData
from pythonmop.monitor.monitor_base import Monitor
from pythonmop.monitor.algorithm_a import AlgorithmA
from pythonmop.debug_utils import debug_message, debug
from pythonmop.statistics import StatisticsSingleton

import os
from typing import Dict, List, Any, Type, Tuple
from copy import deepcopy


class MonitorA(Monitor):
    """A class used to store the information of the monitor and track the executions of the program."""

    def __init__(self, formula: str, events: List[str], formalism: str, parameter_event_map: Dict[str, List[Type]],
                 handlers: Dict[str, callable], spec_name: str):
        """Initialize the monitor using the arguments input and create an initial formula handler associated with it.

        Args:
            formula: The formula string input from the instrument part.
            events: The list of events used in the formula.
            formalism: The specific type of the formula (Only allows: ere, fsm, ltl, cfg).
            parameter_event_map: The map between the parameter types and their event name.
            handlers: The error handlers defined by the users when the spec is violated.
            spec_name: The name of the spec being evaluated in the monitor.
        """

        # Print out the debug message for testing purposes.
        if debug:
            debug_message(lambda: f'- Created monitor for spec: {spec_name}')

        # Call the super class __init__() <= Nothing to do.
        super().__init__()

        # Store all the helpful arguments for future usages.
        self.events = events
        self.formalism = formalism
        self.spec_name = spec_name
        self.parameter_event_map = parameter_event_map

        if self.formalism == 'cfg':
            # Create the formula handler directly if the formalism is 'cfg'
            self.formula_handler = self._create_formula_handler(formula, self.formalism)
        else:
            # Parse the formula string based on the input formula, events, and formalism
            formula_string = self._input_parser(formula, events, formalism)
            # Create the formula handler based on the parsed formula string
            self.formula_handler = self._create_formula_handler(formula_string, formalism)

        self.error_handlers = handlers
        self.params_monitor = {'': deepcopy(self.formula_handler)}
        StatisticsSingleton().add_monitor_creation(self.spec_name)  # Update statistics for monitor creation

    def _input_parser(self, formula: str, events: List[str], formalism: str) -> str:
        """Generate the formula handler string based on the string input, the events, and the formalism for it.

        Args:
            formula: The raw formula string input from the instrument part.
            events: The list of events used in the formula.
            formalism: The specific type of the formula (Only allows: ere, fsm, ltl).

        Returns:
            The parsed formula string.
        """
        if formalism == 'ere':
            # Parse ERE formula
            ere_data = EREData(formula, events)
            formula_string = ere_data.toFSM()
        elif formalism == 'fsm':
            # Parse FSM formula
            formula_string = FSMData(formula, events)
        elif formalism == 'ltl':
            # Parse LTL formula
            ltl_data = LTLData(formula, events)
            formula_string = ltl_data.toFSM()
        else:
            raise ValueError(f'ERROR: The formalism "{formalism}" is not supported by the tool!')
        return formula_string.formula

    def _create_formula_handler(self, formula: str, formalism: str) -> Base:
        """Create and store an initial formula handler associated with the monitor.

        Args:
            formula: The formula string generated by the Java logic plugins / raw formula string for CFG.
            formalism: The specific type of the formula (Only allows: ere, fsm, ltl, cfg).

        Returns:
            An instance of a formula handler (Ere, Fsm, Ltl or Cfg).
        """
        if formalism == 'ere':
            # Create Ere formula handler
            return Ere(formula, self.parameter_event_map)
        elif formalism == 'fsm':
            # Create Fsm formula handler
            return Fsm(formula, self.parameter_event_map)
        elif formalism == 'ltl':
            # Create Ltl formula handler
            return Ltl(formula, self.parameter_event_map)
        elif formalism == 'cfg':
            # Create Cfg formula handler
            return Cfg(formula, self.parameter_event_map)

    def clear_trace_file(self) -> None:
        """
        remove the `trace_etc` file (not the `trace_monitor_etc` file) for the monitor if it exists.

        `trace_etc` is a final output file that contains the final state of the monitor after the test
        it is only used for debugging purposes.

        `trace_monitor_etc` is a file that contains the trace of the program it is only used in algo A.
        """
        trace_file_path = f'trace_{self.spec_name}.txt'
        if os.path.exists(trace_file_path):
            os.remove(trace_file_path)

    def update_params_handler(self, event: str, spec_params: Tuple[SpecParameter], param_instances: List[Any],
                              file_name: str, line_num: int, *args: Any, **kwargs: Any) -> None:
        """Find the trace of the program into a trace file in forms of parameter instances' types and ids.

        Args:
            event: The name of the event.
            spec_params: The spec parameter combination.
            param_instances: The parameter instances got called in the testing program.
            file_name: The name of the testing file.
            line_num: The line number of the function got called in the testing file.
            args: Positional arguments.
            kwargs: Keyword arguments.
        """
        with open(f'trace_monitor_{self.spec_name}.txt', 'a') as trace_file:
            # Construct a line to write to the trace file
            line = f'{event}:'
            for spec_param in spec_params:
                param_type = spec_param.param_type
                param_id = spec_param.id
                line += f' {param_type}-{param_id},'

            line = line[:-1] + ';\n'  # Remove the trailing comma and add a semicolon for the final instance.
            trace_file.write(line)  # Write the line generated to the trace file

        # Print out the debug message for testing purposes.
        if debug:
            debug_message(lambda: f'WROTE: event: {event}; parameter type: {param_type}; parameter id: {param_id}')

    def end_trace(self) -> None:
        """Delete the trace file."""
        trace_file_path = f'trace_monitor_{self.spec_name}.txt'
        if os.path.exists(trace_file_path):
            os.remove(trace_file_path)  # Remove the trace file if it exists

    def call_monitors(self, final_state: Dict[str, List[str]]) -> None:
        """Call the monitors of the final state.

        Args:
            final_state: The final state of the formula handler.
        """
        for param in final_state.keys():
            if param not in self.params_monitor.keys():
                # Create a new formula handler if the parameter doesn't exist in the monitor
                self.params_monitor[param] = deepcopy(self.formula_handler)
                # Update statistics for monitor creation
                StatisticsSingleton().add_monitor_creation(self.spec_name)

            for event in final_state[param]:
                # Update the state based on each event
                self.transit_state(event, param, '', 0, '', [], {})

    def transit_state(self, event: str, param: str, file_name: str, line_num: int, custom_message: str, args: Any, kwargs: Any) -> None:
        """Transit the state of the formula handler based on the event performed and execute the handler for violations.

        Args:
            event: The event performed by the program.
            param: The target parameter combination that needs to be updated.
            file_name: The name of the file where the event is performed.
            line_num: The line number of the method in the file where the event is performed.
            args: The arguments passed into the method where the event is performed.
            kwargs: The keyword arguments passed into the method where the event is performed.
        """
        
            # Debug message to trace the state transition call
        if debug:
            try:
                debug_message(lambda: 
                    f'- Called transit_state with event: {event}, param: {param}, file_name: {file_name}, line_num:'
                    f'{line_num}, custom_message: {custom_message}, args: {args}, kwargs: {kwargs}')
            except AttributeError:
                pass

        # Update statistics for the event
        StatisticsSingleton().add_events(self.spec_name, event)
        # Get matched categories from the formula handler transition
        matched_categories = self.params_monitor[param].transition(event)

        # Execute the error handlers defined by the user.
        for matched_category in matched_categories:
            if matched_category in self.error_handlers.keys():
                # Get the error handler function
                func = self.error_handlers[matched_category]
                num_params = func.__code__.co_argcount - 1  # Number of parameters the function takes
                if num_params == 2:
                    func(file_name, line_num)  # Call the function with file name and line number
                elif num_params == 5:
                    func(file_name, line_num, args, kwargs, custom_message)  # Call the function with additional args and kwargs
                else:
                    func()  # Call the function without additional arguments

                # Extract the type of the params
                param_output = []
                param_instances = param.split(',')
                for param_instance in param_instances:
                    param_parts = param_instance.strip(';').split('-')
                    if len(param_parts) == 2:
                        param_type = param_parts[0]
                    else:
                        param_type = '-'.join(param_parts[:-1])
                    param_output.append(param_type)

                # Update statistics for the violation
                StatisticsSingleton().add_violation(self.spec_name,
                                                    f'last event: {event}, param: {param_output}, '
                                                    f'message: {custom_message}, '
                                                    f'file_name: {file_name}, line_num: {line_num}')

    # TODO: To be polished!
    def _default_error_handler(self, event: str, matched_category: str, file_name: str, line_num: int, args: Any,
                               kwargs: Any) -> None:
        """Default error handler which writes the event and the category it matched into a trace file.

        Args:
            event: The event performed by the program.
            matched_category: The category that the event matched.
            file_name: The name of the file where the event is performed.
            line_num: The line number of the method in the file where the event is performed.
            args: The arguments passed into the method where the event is performed.
            kwargs: The keyword arguments passed into the method where the event is performed.
        """
        # Open the trace file in append mode, creating it if it doesn't exist
        with open('trace.txt', 'a') as trace_file:
            # Construct the message to write into the file
            message = (f"Event: {event} is matched to Category: {matched_category}. "
                       f"Called from: {file_name}: line {line_num}. "
                       f"args: {args}, kwargs {kwargs}\n")
            # Write the message to the file
            trace_file.write(message)

    def refresh_monitor(self):
        """Refresh the monitor state for a new test.
        """
        trace_file_path = f'trace_monitor_{self.spec_name}.txt'

        # Check if the trace monitor file exists
        if os.path.exists(trace_file_path):
            # Instantiate AlgorithmA and get the final state
            a = AlgorithmA(self.spec_name)
            final_state = a.algorithm_a()

            # End the current trace
            self.end_trace()

            # Write the final state and its length to the trace file
            with open(f'trace_{self.spec_name}.txt', 'a') as trace_file:
                trace_file.write(f'{final_state}\n{len(final_state)}')

            # Call monitors with the final state
            self.call_monitors(final_state)

    def get_formula_handler(self) -> Base:
        """Return the current initial formula handler.

        Returns:
            The initial formula handler associated with the monitor.
        """

        return self.formula_handler
